# Dify ワークフロー サンプル集

全18種のDifyワークフローDSLファイルの解説。すべてDifyにインポートして即実行可能。

---

## 一覧

| ファイル | パターン | モード | ノード数 | LLM使用 |
|---|---|---|---|---|
| [V01](#v01-simple-qa-workflowyml) | ストレートQA | workflow | 3 | 1 |
| [V02](#v02-v02-template-formattingyml) | テンプレート整形 | workflow | 3 | 0 |
| [V03](#v03-v03-api-callyml) | 外部API呼出 | workflow | 3 | 0 |
| [V04](#v04-v04-ragyml) | RAG | workflow | 4 | 1 |
| [V05](#v05-v05-api-summarizeyml) | API→LLM要約 | workflow | 5 | 1 |
| [V06](#v06-v06-data-extractionyml) | 構造化データ抽出 | workflow | 4 | 1 |
| [V07](#v07-v07-llm-to-apiyml) | LLM→API連携 | workflow | 5 | 1 |
| [V08](#v08-v08-if-else-branchyml) | IF/ELSE分岐 | workflow | 6 | 2 |
| [V09](#v09-v09-intent-routingyml) | インテント分類 | workflow | 8 | 2 |
| [V10](#v10-v10-input-validationyml) | 入力バリデーション | workflow | 6 | 1 |
| [V11](#v11-v11-parallel-llmyml) | 並列LLM比較 | workflow | 7 | 3 |
| [V12](#v12-v12-batch-summaryyml) | バッチ要約 | workflow | 6 | 1 |
| [V13](#v13-v13-batch-apiyml) | バッチAPI+集約 | workflow | 7 | 1 |
| [V14](#v14-v14-multi-step-researchyml) | マルチステップ調査 | workflow | 8 | 3 |
| [V15](#v15-v15-chatflow-ragyml) | Chatflow RAG | advanced-chat | 4 | 1 |
| [V16](#v16-v16-chatflow-statefulyml) | Chatflow状態保持 | advanced-chat | 10 | 2 |
| [V17](#v17-v17-guarded-pipelineyml) | 3層ガード | workflow | 12 | 1 |
| [V18](#v18-v18-data-pipelineyml) | LLM不使用ETL | workflow | 6 | 0 |

---

## インポート方法

1. Dify ダッシュボード → スタジオ → 「DSLファイルをインポート」
2. 対象の `.yml` ファイルを選択
3. インポート後、LLMノードのモデル設定を自環境に合わせて変更
4. Knowledge Retrieval ノードがある場合は `dataset-placeholder-id` を実際のデータセットIDに差し替え
5. HTTP Request ノードがある場合は URL を実際のエンドポイントに差し替え

---

## Level 1: 基本構成

### V01: `simple-qa-workflow.yml`

**営業部門 — 提案書のたたき台作成**

```
開始 → 回答を生成(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 営業担当者が顧客訪問前に提案の切り口を短時間で整理する |
| 入力 | `query` (paragraph) — 質問や指示文 |
| 出力 | `result` — LLMの回答テキスト |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | ユーザーからの自由テキスト入力を受け取る |
| 2 | 回答を生成 | gpt-4o-miniで回答生成。安全ガードレール付きシステムプロンプト（違法行為拒否、個人情報生成禁止、プロンプトインジェクション防御） |
| 3 | 終了 | LLMの `text` を `result` として出力 |

**カスタマイズポイント**
- システムプロンプトを業務に合わせて変更（翻訳、要約、企画書作成など用途別に調整）
- `temperature` を下げると正確性重視、上げると創造性重視

---

### V02: `v02-template-formatting.yml`

**人事部門 — 内定通知メールの自動生成**

```
開始 → メール文面生成(TT) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 採用担当が内定者ごとに宛名・入社日・配属先だけ変えて通知メールを生成する |
| 入力 | `name` (text), `date` (text), `department` (text), `position` (text) |
| 出力 | `result` — Jinja2で整形された内定通知メール文 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 4つのテキスト入力（氏名、入社日、配属部署、職種）を受け取る |
| 2 | メール文面生成 | Jinja2テンプレートで「拝啓〜」から始まる正式な通知メールに4変数を埋め込み |
| 3 | 終了 | 整形済みメール文を出力 |

**カスタマイズポイント**
- テンプレートを変更すれば契約書ドラフト、請求書、議事録など任意の定型文書に応用可能
- LLM不使用のためトークンコストゼロ、実行時間1秒未満

---

### V03: `v03-api-call.yml`

**経理部門 — 日次為替レート取得**

```
開始 → 為替レート取得(HTTP) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 海外取引先への支払いに使う為替レートを毎朝取得する |
| 入力 | `base_currency` (text), `target_currency` (text) |
| 出力 | `response_body` — APIレスポンスJSON, `status_code` — HTTPステータス |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 基準通貨（例: USD）と対象通貨（例: JPY）を入力 |
| 2 | 為替レート取得 | `GET https://api.exchangerate.host/latest?base=...&symbols=...` を呼び出し |
| 3 | 終了 | レスポンスボディとステータスコードを出力 |

**カスタマイズポイント**
- URLを任意のREST APIに変更するだけで、天気情報・在庫確認・価格取得など汎用的に使える
- Schedule Trigger と組み合わせれば毎朝自動実行も可能

---

## Level 2: 直列拡張

### V04: `v04-rag.yml`

**情報システム部門 — 社内規程の問い合わせ対応**

```
開始 → 社内規程検索(KR) → 回答生成(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 「出張旅費の上限はいくら？」等の社内規程に関する問い合わせに自動回答する |
| 入力 | `query` (paragraph) — 質問テキスト |
| 出力 | `result` — ナレッジベースに基づく回答 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | ユーザーの質問を受け取る |
| 2 | 社内規程検索 | ナレッジベースから関連文書を検索（multi-way retrieval, top_k=3, score_threshold=0.5） |
| 3 | 回答生成 | 検索結果を `context` としてLLMに注入。コンテキストにない情報は「見つかりませんでした」と回答するよう指示 |
| 4 | 終了 | 回答テキストを出力 |

**カスタマイズポイント**
- `dataset_ids` を実際のナレッジベースIDに差し替えが必要
- `top_k` を増やすとより多くの文書を参照するが、トークン消費も増加

---

### V05: `v05-api-summarize.yml`

**マーケティング部門 — 競合プレスリリースの日次サマリ**

```
開始 → コンテンツ取得(HTTP) → テキスト抽出(Code) → 要約・分析(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 競合サイトのURLを入力するとHTMLを取得→テキスト抽出→LLMで要約・影響度判定する |
| 入力 | `url` (text) — 分析対象のURL |
| 出力 | `result` — 要約レポート（要点・影響度付き） |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 対象URLを入力 |
| 2 | コンテンツ取得 | 指定URLにGETリクエスト |
| 3 | テキスト抽出 | Python3でHTML→プレーンテキスト変換（script/styleタグ除去、HTMLエンティティデコード、10000文字にトランケート） |
| 4 | 要約・分析 | 競合分析の専門家として、キーポイント抽出・影響度（高/中/低）判定・推奨アクションを生成 |
| 5 | 終了 | 分析レポートを出力 |

**カスタマイズポイント**
- Codeノードのテキスト抽出ロジックをRSS/XMLパーサーに変更してRSSフィード対応も可能
- 複数URLの処理はV12（バッチ要約）パターンで対応

---

### V06: `v06-data-extraction.yml`

**総務部門 — 名刺情報のCRM登録**

```
開始 → パラメータ抽出(PE) → CSV変換(TT) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 展示会で集めた名刺のOCR結果から会社名・氏名・電話番号等を抽出し、CSV形式で出力する |
| 入力 | `card_text` (paragraph) — 名刺OCR結果のテキスト |
| 出力 | `result` — CSV形式の構造化データ |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 名刺テキストを入力 |
| 2 | パラメータ抽出 | gpt-4o-miniで5フィールド抽出: `company`(必須), `name`(必須), `title`, `phone`, `email` |
| 3 | CSV変換 | Jinja2テンプレートで `company,name,title,phone,email` のCSVヘッダー付きレコードを生成 |
| 4 | 終了 | CSV文字列を出力 |

**カスタマイズポイント**
- パラメータ定義を変更すれば請求書・領収書・契約書など任意の非構造化データ→構造化変換に応用可能
- テンプレートをJSON形式に変更すればAPI連携にも直結

---

### V07: `v07-llm-to-api.yml`

**開発チーム — 障害報告の自動Slack通知**

```
開始 → アラート要約(LLM) → Payload生成(Code) → Slack通知(HTTP) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 監視アラートの原文をLLMが「影響・原因・推奨アクション」に要約し、Slackに自動投稿する |
| 入力 | `alert_text` (paragraph) — 監視アラートの原文 |
| 出力 | `status_code`, `response_body` — Slack APIのレスポンス |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | アラートテキストを入力 |
| 2 | アラート要約 | 運用監視の専門家として「影響:」「原因:」「推奨:」の3行フォーマットで要約 |
| 3 | Payload生成 | Python3でSlack Webhook用JSONペイロードを組み立て |
| 4 | Slack通知 | `POST https://hooks.slack.com/services/...` でSlackに送信 |
| 5 | 終了 | APIレスポンスを出力 |

**カスタマイズポイント**
- Webhook URLを実際のSlackワークスペースのURLに差し替え
- Teams、Discord、LINE Notify等にもHTTPノードのURL/payload変更で対応可能

---

## Level 3: 分岐・合流

### V08: `v08-if-else-branch.yml`

**グローバル企業 — 日英バイリンガルFAQ**

```
開始 → 言語判定(IE) →true→ LLM-EN → 結果集約(VA) → 終了
                     →false→ LLM-JA ↗
```

| 項目 | 内容 |
|---|---|
| 業務シーン | ユーザーが選択した言語（English/Japanese）に応じて、異なるプロンプトのLLMで回答する |
| 入力 | `query` (paragraph), `language` (select: English / Japanese) |
| 出力 | `result` — 選択言語に応じた回答 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 質問テキストと言語選択を受け取る |
| 2 | 言語判定 | `language is "English"` で分岐 |
| 3 | LLM-EN | 英語の企業FAQアシスタントとして回答（true分岐） |
| 4 | LLM-JA | 日本語の企業FAQアシスタントとして回答（false分岐） |
| 5 | 結果集約 | 両ブランチの出力を Variable Aggregator で統合 |
| 6 | 終了 | 集約結果を出力 |

**カスタマイズポイント**
- 言語を3つ以上に増やす場合は Question Classifier（V09パターン）に切り替え
- 分岐条件を文字数判定に変えれば「短い回答/詳細な回答」の切り替えにも応用可能

---

### V09: `v09-intent-routing.yml`

**EC事業部 — 統合カスタマーサポート窓口**

```
開始 → インテント分類(QC) →商品質問→ 商品KB検索(KR) → 商品回答(LLM) → 終了
                           →注文確認→ 注文API(HTTP) → 注文情報整形(TT) → 終了
                           →一般質問→ 一般回答(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 「この靴は防水？」→KB検索、「注文状況は？」→API照会、「営業時間は？」→LLM汎用回答と自動振り分け |
| 入力 | `query` (paragraph) — 顧客の質問 |
| 出力 | `product_answer` / `order_info` / `general_answer` — 分類別の回答 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 顧客の質問を受け取る |
| 2 | インテント分類 | gpt-4o-miniで3クラスに分類: 商品質問(`class_product`), 注文確認(`class_order`), 一般質問(`class_general`) |
| 3a | 商品KB検索 | 商品ナレッジベースから関連情報を検索 |
| 4a | 商品回答 | 検索結果をcontext注入して商品に関する回答を生成 |
| 3b | 注文API | `GET https://api.example.com/orders` で注文情報を取得 |
| 4b | 注文情報整形 | APIレスポンスを読みやすいフォーマットに整形 |
| 3c | 一般回答 | 汎用プロンプトで営業時間等の一般質問に回答 |
| 5 | 終了 | 3ブランチの出力を集約 |

**カスタマイズポイント**
- 分類クラスの追加・変更は `classes` 配列を編集するだけ
- 各ブランチに独立したパイプラインを構築できるため、後から機能追加が容易

---

### V10: `v10-input-validation.yml`

**金融機関 — ローン相談AIの入力防御**

```
開始 → 入力検証(Code) → 条件分岐(IE) →true→ ローン相談AI(LLM) → 終了
                                      →false→ エラーメッセージ(TT) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | プロンプトインジェクションや不正入力をCodeノードで検出し、LLMに到達させない |
| 入力 | `query` (paragraph) — ユーザーの相談内容 |
| 出力 | `result` — ローン相談回答またはエラーメッセージ |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | ユーザー入力を受け取る |
| 2 | 入力検証 | Python3で正規表現チェック: `ignore.*instructions`, `system prompt`, `forget.*previous` 等のインジェクションパターンを検出。文字数チェック（0〜5000文字） |
| 3 | 条件分岐 | `is_valid` が `"true"` なら正常パス、`"false"` ならエラーパス |
| 4a | ローン相談AI | 住宅ローン専門アドバイザーとして金利・返済・審査基準等を回答 |
| 4b | エラーメッセージ | 「入力内容を処理できませんでした」の定型メッセージを出力 |
| 5 | 終了 | いずれかの結果を出力 |

**カスタマイズポイント**
- 検証ロジック（禁止パターン正規表現）は業務要件に合わせて拡張
- `sensitive_word_avoidance` との併用で二重のガードを構成

---

### V11: `v11-parallel-llm.yml`

**AI推進室 — LLMモデル選定のベンチマーク**

```
開始 →→ Model A(LLM) →→ 回答集約(VA) → 比較レポート生成(TT) → 終了
     →→ Model B(LLM) ↗
     →→ Model C(LLM) ↗
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 同じ質問を3つのモデルに同時送信し、回答品質を並べて比較する |
| 入力 | `query` (paragraph) — 評価用の質問 |
| 出力 | `result` — 3モデルの回答比較レポート |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 評価用質問を入力 |
| 2a | Model A | gpt-4o-miniで回答（本番では異なるモデルに差し替え） |
| 2b | Model B | 同一プロンプトで回答 |
| 2c | Model C | 同一プロンプトで回答 |
| 3 | 回答集約 | 3つのLLM出力を Variable Aggregator で1つに統合 |
| 4 | 比較レポート生成 | Jinja2テンプレートで「Model A / Model B / Model C」のセクション別にフォーマット |
| 5 | 終了 | 比較レポートを出力 |

**カスタマイズポイント**
- 各LLMノードの `model.provider` / `model.name` を実際に比較したいモデルに変更
- 並列ブランチは最大10本まで追加可能
- 応答時間・トークン数はDifyのログ画面で確認可能

---

## Level 4: ループ・反復処理

### V12: `v12-batch-summary.yml`

**広報部門 — メディア掲載記事の週次レビュー**

```
開始 → 記事配列化(Code) → [Iteration: 記事分析LLM] → レポート生成(TT) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 複数の記事テキストをまとめて投入し、各記事の要約・論調（Positive/Negative/Neutral）・対応要否を一括分析する |
| 入力 | `articles` (paragraph) — 空行区切りの記事テキスト群 |
| 出力 | `report` — 全記事の分析をまとめたMarkdownレポート |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 空行（`\n\n`）で区切った記事テキストを入力 |
| 2 | 記事配列化 | Python3で空行スプリット→配列に変換 |
| 3 | 記事イテレーション | 配列の各要素を並列処理（`parallel_mode: true`, `start_node_id: 12000000000004`） |
| 3-inner | 記事分析LLM | 各記事を「要約（2行）/ 論調 / 対応要否」フォーマットで分析 |
| 4 | レポート生成 | イテレーション結果をMarkdownレポートに整形 |
| 5 | 終了 | 完成レポートを出力 |

**カスタマイズポイント**
- 入力の区切り文字をCode内で変更可能（改行、カンマ、JSON配列等）
- `error_handle_mode: continue-on-error` で一部記事が失敗しても残りは処理継続

---

### V13: `v13-batch-api.yml`

**調達部門 — サプライヤー価格の一括比較**

```
開始 → サプライヤー配列化(Code) → [Iteration: 価格見積API(HTTP)] → 結果集約(Code) → 最適サプライヤー分析(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 複数サプライヤーの見積APIを一括呼出し、コスト・リードタイム・在庫を比較して最適サプライヤーを推奨する |
| 入力 | `part_number` (text) — 部品番号, `suppliers` (text) — カンマ区切りのサプライヤー名 |
| 出力 | `recommendation` — 比較分析と推奨サプライヤー |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 部品番号とサプライヤーリストを入力 |
| 2 | サプライヤー配列化 | カンマ区切り→配列変換 |
| 3 | サプライヤーイテレーション | 各サプライヤーに対して並列APIリクエスト（`start_node_id: 13000000000004`） |
| 3-inner | 価格見積API | `GET .../quote?part=...&supplier=...` で見積取得 |
| 4 | 結果集約 | Python3で全レスポンスを「サプライヤー / 価格 / リードタイム / 在庫」の表形式テキストに集約 |
| 5 | 最適サプライヤー分析 | 調達の専門家としてコスト・納期・在庫の3観点で評価し推奨 |
| 6 | 終了 | 推奨レポートを出力 |

**カスタマイズポイント**
- APIのURLを実際のサプライヤー見積APIに差し替え
- Codeの集約ロジックでレスポンスのJSONキー名を実APIに合わせて調整

---

### V14: `v14-multi-step-research.yml`

**経営企画 — 新規事業の市場調査レポート自動生成**

```
開始 → リサーチ計画(LLM) → 計画パース(Code) → [Iteration: 検索API(HTTP) → 項目分析(LLM)] → 最終レポート生成(LLM) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | テーマを入力するとLLMが調査項目を自動計画→各項目を検索API+LLMで調査→SWOT分析付き最終レポートを生成する |
| 入力 | `theme` (paragraph) — 調査テーマ |
| 出力 | `result` — エグゼクティブサマリー＋SWOT分析付き調査レポート |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 調査テーマを入力 |
| 2 | リサーチ計画 | テーマから5つの調査項目をJSON配列で生成（例: `["市場規模", "主要プレイヤー", ...]`） |
| 3 | 計画パース | Python3でJSON文字列→配列に変換。パース失敗時はデフォルト5項目にフォールバック |
| 4 | 調査イテレーション | 5項目を並列処理（`start_node_id: 14000000000005`） |
| 4a | 検索API | 各調査項目で検索APIを呼び出し |
| 4b | 項目分析 | 検索結果を分析し3〜5個の箇条書きにまとめる |
| 5 | 最終レポート生成 | 全調査結果を統合し、エグゼクティブサマリー＋本文＋SWOT分析のレポートを作成 |
| 6 | 終了 | 完成レポートを出力 |

**カスタマイズポイント**
- 検索APIのURLを Google Custom Search API や Bing Search API に差し替え
- 調査項目数はリサーチ計画LLMのプロンプト（「5つ」の部分）を変更して調整
- 最終レポートのフォーマット（PEST分析、5 Forces等）もプロンプトで変更可能

---

## Level 5: 複合パターン

### V15: `v15-chatflow-rag.yml`

**法務部門 — 契約書レビュー支援チャットボット**

```
開始 → ナレッジ検索(KR) → 法務AIアシスタント(LLM+memory) → 応答(Answer)
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 契約書の条項について「このリスクは？」「修正案を出して」と会話しながら段階的にレビューする |
| モード | **advanced-chat**（マルチターン会話） |
| 入力 | `sys.query` — 自動（ユーザーのチャット入力） |
| 出力 | ストリーミング応答 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | Chatflowのため入力変数なし（`sys.query` が自動利用） |
| 2 | ナレッジ検索 | 法務ナレッジベース（契約書テンプレート・レビューガイドライン）から検索。multi-way, top_k=5 |
| 3 | 法務AIアシスタント | context有効（KR結果注入）+ memory有効（直近10ターン保持）。リスク判定（高/中/低）、修正案の提示、法的助言でない旨の付記を指示 |
| 4 | 応答 | LLMの生成テキストをストリーミングで返す |

**カスタマイズポイント**
- `dataset_ids` を法務ナレッジベースの実IDに差し替え
- memory window `size` を増減して文脈保持量を調整
- 会社の法務レビュー基準をシステムプロンプトに追記

---

### V16: `v16-chatflow-stateful.yml`

**通信会社 — コールセンターAIアシスタント**

```
開始 → 問い合わせ分類(QC) →注文系→ パラメータ抽出(PE) → 注文API照会(HTTP) → 注文対応AI(LLM) → 顧客ID保存(VAs) → 注文応答(Answer)
                           →製品系→ 製品ナレッジ検索(KR) → 製品対応AI(LLM) → 製品応答(Answer)
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 「料金プランを変更したい」→CRM検索、「製品の使い方」→KB検索と自動振り分け。顧客情報を会話変数で保持する |
| モード | **advanced-chat**（マルチターン会話） |
| 入力 | `sys.query` — 自動 |
| 出力 | ストリーミング応答 |
| 会話変数 | `customer_id` (string) — ターンをまたいで顧客IDを保持 |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | Chatflowの自動入力 |
| 2 | 問い合わせ分類 | 2クラス分類: `class_order`（注文・契約）, `class_product`（製品・サービス） |
| 3a | パラメータ抽出 | 問い合わせから `phone_number`, `order_id` を抽出 |
| 4a | 注文API照会 | `GET .../orders?phone=...&order_id=...` で注文情報取得 |
| 5a | 注文対応AI | API結果を元に丁寧に回答（memory有効で会話履歴保持） |
| 6a | 顧客ID保存 | 抽出した `phone_number` を会話変数 `customer_id` に保存 |
| 7a | 注文応答 | 注文系の回答をストリーミング出力 |
| 3b | 製品ナレッジ検索 | 製品マニュアル・FAQのKBから検索 |
| 4b | 製品対応AI | KB結果をcontext注入し、ステップバイステップで回答（memory有効） |
| 5b | 製品応答 | 製品系の回答をストリーミング出力 |

**カスタマイズポイント**
- 分類クラスの追加（例: `class_billing` 請求関連）でブランチ拡張可能
- 会話変数に保存する情報を増やせば、よりパーソナライズされた対応が可能
- 注文APIのURLを実際のCRM/基幹システムに差し替え

---

### V17: `v17-guarded-pipeline.yml`

**医療機関 — 患者向け症状説明AI（3層ガード）**

```
開始 → 入力サニタイズ(Code) → 入力安全判定(IE) →true→ 医療ナレッジ検索(KR) → 症状説明AI(LLM) → 出力検証(Code) → 出力安全判定(IE) →true→ 正常終了
                                               →false→ 入力拒否応答(TT) → 入力拒否終了                                              →false→ 出力拒否応答(TT) → 出力拒否終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 患者が症状について質問するAI。入力・LLM・出力の3段階で安全チェックを行い、不適切な医療情報の提供を防止する |
| 入力 | `query` (paragraph) — 症状に関する質問 |
| 出力 | `result` — 安全な医療情報、または拒否応答 |
| 終了ノード | 3つ（正常終了 / 入力拒否終了 / 出力拒否終了） |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 患者からの質問入力 |
| 2 | 入力サニタイズ | 保険証番号・マイナンバーのパターン検出、インジェクションパターンチェック |
| 3 | 入力安全判定 | `is_safe == "true"` で分岐 |
| 4 | 医療ナレッジ検索 | 承認済み医療コンテンツのKBから検索 |
| 5 | 症状説明AI | 「診断しない」「薬を処方しない」「必ず受診を促す」制約付きプロンプト |
| 6 | 出力検証 | 禁止表現チェック: 「と診断します」「処方します」「未承認薬」等を検出 |
| 7 | 出力安全判定 | `output_safe == "true"` で分岐 |
| 8a | 正常終了 | 検証済み回答を出力 |
| 8b | 入力拒否終了 | 個人情報入力不可の旨を案内 |
| 8c | 出力拒否終了 | 医療機関への受診を案内 |

**カスタマイズポイント**
- 入力検証の禁止パターン（正規表現）を業界規制に合わせて拡張
- 出力検証の禁止表現リストをコンプライアンス基準に合わせて調整
- `sensitive_word_avoidance` との4層ガードも可能

---

### V18: `v18-data-pipeline.yml`

**物流部門 — 出荷データの基幹→WMS自動連携**

```
開始 → ERP注文取得(HTTP) → ERP→WMS変換(Code) → WMS API整形(TT) → WMS送信(HTTP) → 終了
```

| 項目 | 内容 |
|---|---|
| 業務シーン | 基幹システム（ERP）から受注確定データを取得し、倉庫管理システム（WMS）のフォーマットに変換して自動連携する |
| 入力 | `order_status` (text, デフォルト "confirmed") — 取得する注文ステータス |
| 出力 | `status_code`, `response_body` — WMS APIのレスポンス |
| LLM | **不使用**（トークンコストゼロ） |

**ノード詳細**

| # | ノード | 処理内容 |
|---|---|---|
| 1 | 開始 | 注文ステータス（confirmed等）を指定 |
| 2 | ERP注文取得 | `GET .../erp/orders?status=confirmed` でERPから受注データを取得 |
| 3 | ERP→WMS変換 | Python3で ERPフォーマット→WMSフォーマットにマッピング（order_number→shipment_id, product_code→sku, quantity→qty, shipping_zip→dest_zip） |
| 4 | WMS API整形 | Jinja2テンプレートでWMS APIのエンベロープ `{"api_version": "2.0", "shipments": ...}` を生成 |
| 5 | WMS送信 | `POST .../wms/inbound` でWMSにデータ送信 |
| 6 | 終了 | 送信結果を出力 |

**カスタマイズポイント**
- ERP/WMS の APIエンドポイント・認証設定を実環境に差し替え
- Codeのフィールドマッピングを実際のERPレスポンス構造に合わせて調整
- Schedule Trigger と組み合わせれば毎日の定時バッチ処理として自動実行可能

---

## 全体統計

| 指標 | 値 |
|---|---|
| 合計ファイル数 | 18 |
| Workflow モード | 16 |
| Chatflow (advanced-chat) モード | 2 (V15, V16) |
| 合計ノード数 | 108 |
| LLM ノード | 18 |
| Code ノード | 8 |
| HTTP Request ノード | 9 |
| Template Transform ノード | 8 |
| Knowledge Retrieval ノード | 5 |
| Question Classifier ノード | 2 |
| Parameter Extractor ノード | 2 |
| Iteration ノード | 3 |
| If-Else ノード | 4 |
| Variable Aggregator ノード | 2 |
| Variable Assigner ノード | 1 |
